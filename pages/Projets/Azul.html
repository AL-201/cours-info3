<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio - Projets</title>
    <link rel="stylesheet" href="../../css/variables.css" />
    <link rel="stylesheet" href="../../css/styles.css" />
    <link rel="stylesheet" href="../../css/Individual_Project.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
  </head>

  <body>
    <input
      type="checkbox"
      id="theme-toggle"
      aria-label="checkbox dark mode"
      hidden
    />

    <!-- Header -->
    <header>
      <h1 class="logo">Portfolio</h1>
      <nav>
        <a href=".././index.html">Accueil</a>
        <a href="../pages_2.html">Projets</a>
        <a href="../pages_3.html">À Propos</a>
      </nav>

      <section class="header-right">
        <a href="../../index.html#contact" class="bouton-contact"
          >Me Contacter</a
        >

        <label for="theme-toggle" class="theme-icon">
          <i class="fas fa-sun"></i>
          <i class="fas fa-moon"></i>
        </label>
      </section>
    </header>

    <main class="Projet-Azul">
      <section class="layout-projet">
        <!-- Bloc Gauche : Explications -->
        <aside class="projet-info">
          <h2>Projet Azul</h2>
          <p>PlaceHolder à remplir</p>
        </aside>

        <!-- Bloc Droit : Code (Duplicable) -->
        <section class="projet-codes">
          <!-- 1er Bloc -->
          <article class="code-block">
            <h3>Constantes</h3>
            <pre><code>
# Elements Collectifs
sac = {}
Tuile_FirstP = [True]
FirstP = [None]
TourN = 0
Fabriques = {}
middle = []
trash = []
PlayerNumber = 3
Score = {}
Banned = []

# Elements Personnels
MotifP1 = []
WallP1 = []
PlancherP1 = {}

MotifP2 = []
WallP2 = []
PlancherP2 = {}

MotifP3 = []
WallP3 = []
PlancherP3 = {}

MotifP4 = []
WallP4 = []
PlancherP4 = {}

#Utilitaire
PointPlancher = {1:-1,2:-1,3:-2,4:-2,5:-2,6:-3,7:-3}
Tuiles = ["BLUE_TILE", "YELLOW_TILE", "RED_TILE", "BLACK_TILE", "GREEN_TILE"]
Tuiles_selec = {1:"BLUE_TILE",2:"YELLOW_TILE",3:"RED_TILE",4:"BLACK_TILE",5:"GREEN_TILE"}
Tuiles_wall = {1:{"BLUE_TILE":1, "YELLOW_TILE":2, "RED_TILE":3, "BLACK_TILE":4, "GREEN_TILE":5},2:{"GREEN_TILE":1, "BLUE_TILE":2, "YELLOW_TILE":3, "RED_TILE":4, "BLACK_TILE":5},3:{"BLACK_TILE":1, "GREEN_TILE":2, "BLUE_TILE":3, "YELLOW_TILE":4, "RED_TILE":5},4:{"RED_TILE":1, "BLACK_TILE":2, "GREEN_TILE":3, "BLUE_TILE":4, "YELLOW_TILE":5},5:{"YELLOW_TILE":1, "RED_TILE":2, "BLACK_TILE":3, "GREEN_TILE":4, "BLUE_TILE":5}}

DWall = {1:WallP1,2:WallP2,3:WallP3,4:WallP4}
DPlancher = {1:PlancherP1,2:PlancherP2,3:PlancherP3,4:PlancherP4}
DMotif = {1:MotifP1,2:MotifP2,3:MotifP3,4:MotifP4}
                </code></pre>
          </article>

          <!-- 2eme Bloc -->
          <article class="code-block">
            <h3>Azul_Engine</h3>
            <pre><code>
# coding: utf-8

from constants import *
from random import randrange


## ----- Init Function ----- ##

def init_game():
    init_sac()
    init_fabriques()
    init_player()

def init_sac():
    for i in Tuiles:
        sac[i]=20

def init_fabriques():
     for i in range(1,2*PlayerNumber+2):
        Fabriques[i]=[]

def init_player():
    for i in range(1,PlayerNumber+1):
        init_motif(i)
        init_wall(i)
        init_score(i)
        init_plancher(i)

def init_motif(p):
    for i in range(1,6):
        (DMotif[p]).append([])
        for j in range(i):
            (DMotif[p])[i-1].append("X")
    
def init_wall(p):
    for i in range(1,6):
        (DWall[p]).append([])
        for j in range(5):
            (DWall[p])[i-1].append("X")

def init_score(p):
    Score[p]=0

def init_plancher(p):
    for i in range(1,8):
        (DPlancher[p])[i]=None




def start_tour():
    FirstP[0]=1
    for i in range(1,2*PlayerNumber+2):
        Fab_refill(i)
    global TourN
    TourN+=1
    print(f"--- \n\n Début du Tour n°{TourN} ! \n")





## ----- Tuiles Function ----- ##
 
def sac_refill():
    for i in range(len(trash)):
        sac[trash[0]]+=1
        trash.remove(trash[0])

def sac_empty():
    s_count = 0
    for k in Tuiles:
        if sac[k]!=0:
            s_count+=1
    if s_count==0 : return True
    else : return False

def Fab_refill(n):
    for j in range(4):
        if sac_empty() : sac_refill()
        if sac_empty() : break
        flag = True
        while flag:
            t = randrange(1,6)
            if sac[Tuiles_selec[t]]!=0:
                Fabriques[n].append((Tuiles_selec[t]))
                sac[Tuiles_selec[t]]-=1
                flag = False

def use_fab(fab, color):
    nb = 0
    for i in range(4):
        if Fabriques[fab][0] == color :
            nb+=1 
        else : middle.append(Fabriques[fab][0])
        Fabriques[fab].remove(Fabriques[fab][0]) 
    return nb

def use_mid(fab, color):
    nb = 0
    j = 0
    for i in range(len(middle)):
        if middle[j]==color:
            nb+=1
            middle.remove(middle[j])
        else: j+=1
    return nb

def tuile_place(p, c_tuile, nb, l_motif):
    if l_motif == -1:
        count = nb
        for i in range(nb):
            # ajoute les tuiles dans le plancher
            for j in range(1,8):
                if (DPlancher[p])[j] is None:
                    (DPlancher[p])[j] = c_tuile
                    count -= 1
                    break
        return count
    count = nb
    for i in range(len((DMotif[p])[l_motif-1])):
        if count > 0 and (DMotif[p])[l_motif-1][i] == "X":
            (DMotif[p])[l_motif-1][i] = c_tuile
            count-=1
    # les tuiles restantes vont dans le plancher
    for i in range(count):
        for j in range(1,8):
            if (DPlancher[p])[j] is None:
                (DPlancher[p])[j] = c_tuile
                break
    return 0




## ----- Count Function (~Score) ----- ##

def plancher_count(p, First_P=False):
    if First_P:
        for i in (DPlancher[p]):
            if (DPlancher[p])[i] is None:
                (DPlancher[p])[i] = "Tuile_FirstP"
                break

def add_score(p, P_horizontal, P_vertical): #3;1
    Score_h = 0; Score_v = 0
    H = check_score_h(p, P_vertical)
    V = check_score_v(p, P_horizontal)
    Score_h += count_consecutive(H, P_horizontal)
    Score_v += count_consecutive(V, P_vertical)

    if Score_h == 1 and Score_v == 1:
        Score[p] += 1
    else:
        if Score_h > 1:
            Score[p] += Score_h
        if Score_v > 1:
            Score[p] += Score_v

def count_consecutive(L, index):
    count = 1 
    if L[index-1] != "O":
        return 0
    
    i = index - 2
    while i >= 0 and L[i] == "O":
        count += 1;i -= 1
    i = index
    while i &lt; len(L) and L[i] == "O":
        count += 1; i += 1

    return count

def add_plancher(p):
    for i in (DPlancher[p]):
        if (DPlancher[p])[i] == "O":
            Score[p] += PointPlancher[i]
            
        if (DPlancher[p])[i] == "P":
            Score[p] += PointPlancher[i]
            global FirstP, Tuile_FirstP
            FirstP[0] = p
            Tuile_FirstP[0] = True
    init_plancher(p)      





## ----- Check Function ----- ##

def check_move(fab, c_tuile):
    temp = []
    for i in range(1,PlayerNumber*2+2):
        temp.append(i)
    temp.append(-1)
    if fab >= 0 :
        if fab in temp and c_tuile in Tuiles and c_tuile in Fabriques[fab]:
            return False
    else: 
        if fab in temp and c_tuile in Tuiles and c_tuile in middle:
            return False
    return True

def check_placement(p, l_motif, color):
    if l_motif == -1:
        return False
    if (DWall[p])[l_motif-1][(Tuiles_wall[l_motif][color])-1]=="O":
        return True
    if (DMotif[p])[l_motif-1][0] != "X" and (DMotif[p])[l_motif-1][0] != color :
        return True
    return (is_motif_full(p, l_motif-1))
    
def is_tour_finished():
    not_empty_count = 0
    for fab in Fabriques:
        if Fabriques[fab] != []:
            not_empty_count+=1
    if middle != [] : not_empty_count+=1
    if not_empty_count==0 : return True
    return False

def is_motif_full(p,l):
    count = 0
    for i in (DMotif[p])[l]:
        if i != "X" :
            count +=1
    if count == len((DMotif[p])[l]) :
        return True
    return False  

def l_motif_full(p,l, color):
    (DWall[p])[l][(Tuiles_wall[l+1][color])-1] = "O"
    for j in range(l+1):
        (DMotif[p])[l][j]="X"
    for j in range(l):
        trash.append(color)

def check_score_h(p, P_v):
    L = []
    for i in range(5):
        L.append((DWall[p])[P_v-1][i])
    return L

def check_score_v(p, P_h):
    L = []
    for i in range(5):
        L.append((DWall[p])[i][P_h-1])
    return L

def is_game_finished():
    for player in range(1,PlayerNumber+1):
        for ligne in range(5):
            if is_wall_full(player,ligne):
                return True
    return False

def is_wall_full(p,l):
    count = 0
    for i in (DWall[p])[l]:
        if i == "O" :
            count +=1
    if count == len((DWall[p])[l]) :
        return True
    return False 

def is_column_wall_full(p,l):
    count = 0
    for i in range(5):
        if (DWall[p])[i][l] == "O" :
            count +=1
    if count == 5 :
        return True
    return False 

def is_all_color(p,n):
    couleur = Tuiles_selec[n+1]
    count = 0
    for ligne, couleurs in Tuiles_wall.items():
        col = couleurs[couleur]
        if (DWall[p])[ligne-1][col-1] == "O":
            count += 1
    return count == 5

def bonus_score(p):
    for num in range(5):
        if is_wall_full(p, num): Score[p]+=2
        if is_column_wall_full(p, num): Score[p]+=7
        if is_all_color(p, num): Score[p]+=10






def end_tour():
    for player in range(1,PlayerNumber+1):
        for ligne in range(5):
            if is_motif_full(player,ligne):
                color = (DMotif[player])[ligne][0]
                l_motif_full(player,ligne, color) 
                add_score(player, P_horizontal=(Tuiles_wall[ligne+1][color]), P_vertical=ligne+1)
        add_plancher(player)
        if Score[player] &lt; 0:
            Score[player]=0
                </code></pre>
          </article>

          <!-- 3eme Bloc -->
          <article class="code-block">
            <h3>Partie Graphique</h3>
            <pre><code>
# coding: utf-8

import pygame
import math
from constants import *
import os

TILES_IMG = {
    "YELLOW_TILE": pygame.image.load(os.path.join("assets", "tile_y.png")),
    "RED_TILE": pygame.image.load(os.path.join("assets", "tile_r.png")),
    "GREEN_TILE": pygame.image.load(os.path.join("assets", "tile_g.png")),
    "BLUE_TILE": pygame.image.load(os.path.join("assets", "tile_b.png")),
    "BLACK_TILE": pygame.image.load(os.path.join("assets", "tile_0.png")),
    "PLAYER_ONE_TILE": pygame.image.load(os.path.join("assets", "number-1.png")),
}
CHEVRON_IMG = pygame.image.load(os.path.join("assets", "chevron.png"))
CIRCLE_IMG = pygame.image.load(os.path.join("assets", "circle.png"))
OK_IMAGE = pygame.image.load(os.path.join("assets", "ok-button.png"))

WHITE = (255, 255, 255)
RED = (255, 0, 0)
GRAY = (200, 200, 200)
LIGHTGRAY = (240, 240, 240)

WIDTH, HEIGHT = 1200, 800

BD_FRAME_WIDTH = 500
BD_FRAME_HEIGHT = 330
BD_TEXT_MARGIN = 20
BD_INNER_MARGIN = 50
BD_SCORE_OFFSET = 400

TILE_W = 32
TILE_H = 32
TILE_SPACING = 6


def create_main_window():
    """Création de la fenêtre et initialisation des éléments nécessaires"""
    global WIN, FONT, SMALLFONT
    pygame.font.init()
    FONT = pygame.font.SysFont(None, 24)
    SMALLFONT = pygame.font.SysFont(None, 16)
    WIN = pygame.display.set_mode((WIDTH, HEIGHT))


def clear_window():
    WIN.fill(WHITE)


def drawboard_player_name(player, x, y):
    """Affiche le nom du joueur passé en paramètre"""
    player_img = FONT.render("Player " + str(player), True, (0, 0, 0))
    WIN.blit(player_img, (x + BD_TEXT_MARGIN, y + BD_TEXT_MARGIN))


def drawboard_score(score, x, y):
    """Affiche le score passé en paramètre"""
    pass


def drawboard_frame(bold, x, y):
    """Dessine un cadre autour du plateau d'un joueur"""
    if bold:
        width = 6
        color = GRAY
    else:
        width = 1
        color = LIGHTGRAY
    pygame.draw.rect(WIN, color, (x, y, BD_FRAME_WIDTH, BD_FRAME_HEIGHT), width, 3)


def draw_empty_tile(x, y):
    """Dessine un cadre délimitant l'emplacement possible d'une tuile.
    (utile pour les lignes du plateau ainsi que la ligne plancher).
    Retourne le Rect correspondant à la zone occupée. """
    return pygame.draw.rect(WIN, GRAY, (x, y, TILE_W, TILE_H), 1, 2)


def draw_empty_tiles(nb_tiles, x, y, selectable=True):
    """Dessine un ensemble d'emplacements vides. 
    Le paramètre selectable indique si les emplacements peuvent être selectionnables.
    Retourne les Rect correspondants"""
    line = []
    hover = False
    for j in range(nb_tiles):
        rect = draw_empty_tile(
            x + j * (TILE_W + TILE_SPACING), y
        )
        line.append(rect)
        if (selectable and rect.collidepoint(pygame.mouse.get_pos())):
            hover = True
    if hover:
        for rect in line:
            draw_outline_box(rect)
    return line


def draw_small_text(txt, x, y):
    txt_img = SMALLFONT.render(str(txt), True, (0, 0, 0))
    WIN.blit(txt_img, (x, y))
    

def draw_tile(tile, x, y, alpha=255):
    """Dessine une tuile dont le type est passée en paramètre.
    Le paramètre alpha indique le niveau de transparence de la tuile. 
    Retourne un Rect correspondant à la zone occupée par la tuile dessinée."""
    tile_img = TILES_IMG[tile]
    if alpha &lt; 255:
        tile_img = tile_img.convert_alpha()
        tile_img.set_alpha(alpha)
    return WIN.blit(tile_img, (x, y))


def draw_tiles(tiles, x, y, spacing=TILE_SPACING, inline=False, selectable=False):
    """Dessine un ensemble de tuiles en ligne (inline=True),
    ou en grille (inline=False).
    Le paramètre selectable indique si les tuiles peuvent être selectionnables. 
    Retourne une liste de Rect correspondant aux zones occupées par les tuiles."""
    hover = []
    rectangles = []
    if inline:
        nb_cols = len(tiles)
    else:
        nb_cols = int(math.sqrt(len(tiles)))
    for i, tile in enumerate(tiles):
        x_offset = (TILE_W + spacing) * (i % nb_cols) 
        y_offset = (TILE_H + spacing) * (i // nb_cols) 
        rect = draw_tile(tile, x + x_offset, y + y_offset)
        rectangles.append(rect)
        if selectable:
            if rect.collidepoint(pygame.mouse.get_pos()) or tile in hover:
                if tile not in hover:
                    hover.append(tile)
                for i, rect in enumerate(rectangles):
                    if tiles[i] == tile or tiles[i] == PLAYER_ONE_TILE:
                        draw_outline_box(rect)
            
    return rectangles


def draw_chevron(x, y):
    """Dessine un chevron (utilisé sur le plateau)."""
    WIN.blit(CHEVRON_IMG, (x, y))


def draw_fabrik(tiles, x, y, draw_circle=True):
    """Dessine une fabrique à l'emplacement indiqué.
    Dessine un cercle si draw_circle=True.
    Retourne la liste des rectangles des tuiles dessinées."""
    if draw_circle:
        CIRCLE_IMG.set_alpha(100)
        WIN.blit(CIRCLE_IMG, (x - 56, y - 56))

    if len(tiles) > 0:
        return draw_tiles(
            tiles, x, y, spacing=13, inline=False, selectable=True
        )
    else:
        return []


def draw_outline_box(rectangle):
    """Dessine un cadre rouge autour du rectangle passé en paramètre.
    Peut être utilisé pour montrer le survol d'une tuile par la souris."""
    pygame.draw.rect(
        WIN,
        RED,
        (
            rectangle.topleft[0] - 2,
            rectangle.topleft[1] - 2,
            rectangle.width + 4,
            rectangle.height + 4,
        ),
        3,
        2,
    )


def show_popup_dialog(message):
    """Affiche une fenetre popup affichant le message passé en paramètre.
    La popup disparait après avoir cliqué sur OK"""
    font = pygame.font.SysFont(None, 24) 
    text_image = font.render(message, True, (0, 0, 0))
    text_rect = text_image.get_rect(center=WIN.get_rect().center)
    box_rect = text_rect.inflate(60, 110).move(0, 30)

    running = True
    while running:
        pygame.draw.rect(WIN, LIGHTGRAY, box_rect)
        pygame.draw.rect(WIN, GRAY, box_rect, 3, 2)
        WIN.blit(text_image, text_rect)
        button = WIN.blit(
            OK_IMAGE,
            (
                text_rect.centerx - OK_IMAGE.get_width() / 2,
                text_rect.centery + text_rect.height,
            ),
        )

        pygame.display.update()
        for event in pygame.event.get():
            if event.type == pygame.MOUSEBUTTONDOWN and button.collidepoint(event.pos):
                running = False
                </code></pre>
          </article>

          <!-- 4eme Bloc -->
          <article class="code-block">
            <h3>Main Program</h3>
            <pre><code>
# coding: utf-8

from azul_engine import *
from graphics import *


# contient la liste des Rect qui peuvent être cliqués
fabric_tiles_rectangles = []  # tuiles des fabriques
board_empty_lines_rectangles = []  # lignes sur le plateau du joueur courant

# contient la sélection du joueur (fabric, tuile, destination)
selected_fabric = None
selected_tile = None
selected_raw = None


def drawboard_raws(player, x, y):
    """Dessine les lignes sur lesquelles le joueur peut construire."""
    empty_board_raws = []
    for i in range(BOARD_SIZE):
        # les emplacements libres sur la ligne
        empty_line = []
        if i >= len(boards[player][i]):
            nb_empty = i - len(boards[player][i]) + 1
            pos_x = x + BD_INNER_MARGIN + (BOARD_SIZE - i - 1) * (TILE_W + TILE_SPACING)
            pos_y = y + BD_INNER_MARGIN + i * (TILE_H + TILE_SPACING)
            selectable = player == current_player and selected_tile != -1
            empty_line = draw_empty_tiles(nb_empty, pos_x, pos_y, selectable)
        empty_board_raws.append(empty_line)

        # les tuiles déjà posés sur la ligne
        pos_x = (
            x
            + BD_INNER_MARGIN
            + (BOARD_SIZE - len(boards[player][i])) * (TILE_W + TILE_SPACING)
        )
        pos_y = y + BD_INNER_MARGIN + i * (TILE_H + TILE_SPACING)
        draw_tiles(boards[player][i], pos_x, pos_y, inline=True, selectable=False)

        # le chevron
        pos_x = x + BD_INNER_MARGIN + (BOARD_SIZE) * (TILE_W + TILE_SPACING)
        pos_y = y + BD_INNER_MARGIN + i * (TILE_H + TILE_SPACING)
        draw_chevron(pos_x, pos_y)
    return empty_board_raws


def drawboard_wall(player, x, y):
    """Dessine le mur du joueur passé en paramètre"""
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if walls[player][i][j] == -1:
                alpha = 255
            else:
                alpha = 35
            tile = wall_matrix[i][j]
            pos_x = x + BD_INNER_MARGIN + (BOARD_SIZE + j + 1) * (TILE_W + TILE_SPACING)
            pos_y = y + BD_INNER_MARGIN + i * (TILE_H + TILE_SPACING)
            draw_tile(tile, pos_x, pos_y, alpha)


def drawboard_floor(player, x, y):
    """Dessine la ligne plancher du joueur."""
    empty_line = []
    hover = False
    # les cases déjà occupées
    nb_floor_tiles = min(len(PENALTIES), len(floors[player]))
    pos_x = x + BD_INNER_MARGIN
    pos_y = y + BD_INNER_MARGIN + (BOARD_SIZE + 1) * (TILE_H + TILE_SPACING)
    draw_tiles(floors[player][:nb_floor_tiles], pos_x, pos_y, inline=True)

    # les emplacements restants
    nb_empty_tiles = len(PENALTIES) - nb_floor_tiles
    pos_x = x + BD_INNER_MARGIN + nb_floor_tiles * (TILE_W + TILE_SPACING)
    selectable = player == current_player and selected_tile != -1
    empty_line = draw_empty_tiles(nb_empty_tiles, pos_x, pos_y, selectable)
    return empty_line


def draw_board(x, y, player):
    """Dessine le plateau d'un joueur."""
    drawboard_frame(player == current_player, x, y)
    drawboard_player_name(player, x, y)
    drawboard_score(scores[player], x, y)

    empty_board_raws = drawboard_raws(player, x, y)
    empty_floor = drawboard_floor(player, x, y)
    empty_board_raws.append(empty_floor)
    if player == current_player:
        board_empty_lines_rectangles.extend(empty_board_raws)

    drawboard_wall(player, x, y)


def draw_window():
    """Redessine toute la fenêtre de jeu."""

    # On nettoie les liste de Rect
    fabric_tiles_rectangles.clear()
    board_empty_lines_rectangles.clear()

    # On nettoie la fenêtre
    clear_window()

    # Dessine les fabriques et les tuiles :
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[0], 230, 100))
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[1], 80, 250))
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[2], 430, 230))
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[3], 110, 450))
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[4], 370, 420))
    
    # Dessine le centre de la table:
    fabric_tiles_rectangles.append(draw_fabrik(fabrics[-1], 230, 250, False))

    # Dessine les plateaux des joueurs:
    draw_board(650, 70, 0)
    draw_board(650, 420, 1)

    # Indique à l'API pygame que l'affichage a été mis à jour
    pygame.display.update()


def get_fabric_tile_on(x, y):
    """Retourne le numéro de fabrique et la tuile correspondant
    aux coordonnées passées en paramètre.
    Permet de savoir sur quelle tuile on a cliqué.
    Sinon, retourne la fabrique et la tuile sélectionnées auparavant"""
    for i, fabric in enumerate(fabric_tiles_rectangles):
        for j, rect in enumerate(fabric):
            if rect.collidepoint((x, y)):
                return i, fabrics[i][j]
    return selected_fabric, selected_tile


def get_empty_line_on(x, y):
    """Retourne le numéro de ligne du plateau correspondant
    aux coordonnées passées en paramètre.
    Permet de savoir sur quelle ligne on a cliqué."""
    for i, raw in enumerate(board_empty_lines_rectangles):
        for j, rect in enumerate(raw):
            if rect.collidepoint((x, y)):
                return i
    return selected_raw


def main():
    global current_player, selected_fabric, selected_tile

    create_main_window()
    init_game()

    while not is_game_finished():
        start_tour()
        current_player = get_first_player()
        draw_window()
        show_popup_dialog("Début du tour : joueur " + str(current_player))

        while not is_tour_finished():
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()

                if event.type == pygame.MOUSEBUTTONDOWN:
                    # si on détecte un clic: chercher sur quel Rect on a cliqué
                    # => ce qui nous permet de récupérer la tuile, et la fabrique correspondant
                    selected_fabric, selected_tile = get_fabric_tile_on(
                        event.pos[0], event.pos[1]
                    )

                    # ensuite, si une tuile a déjà été sélectionnée,
                    # chercher sur quelle ligne du plateau on a cliqué.
                    if selected_fabric != None:
                        dest_raw = get_empty_line_on(event.pos[0], event.pos[1])

                        # quand on a les 3 infos et que le coup est possible,
                        # on peut jouer le coup et passer au joueur suivant.
                        if check_tile(current_player, selected_tile, dest_raw):
                            play(
                                current_player,
                                selected_fabric,
                                selected_tile,
                                dest_raw,
                            )
                            selected_fabric = None
                            selected_tile = None
                            dest_raw = None
                            draw_window()
                            current_player = (current_player + 1) % len(boards)

            draw_window()

        end_tour()
        draw_window()
    compute_final_scores()

    show_popup_dialog(
        "Partie terminée ! joueur 0: "
        + str(scores[0])
        + " / joueur 1: "
        + str(scores[1])
    )
    pygame.quit()


if __name__ == "__main__":
    main()
                </code></pre>
          </article>
        </section>
      </section>

      <!-- Naviguation entre Projet -->
      <nav class="project-nav-min2">
        <a href="Motus.html" class="arrow-min">← Projet précédent</a>
        <a href="Discord_Bot.html" class="arrow-min">Projet suivant →</a>
      </nav>
    </main>

    <!-- Footer -->
    <footer>
      <nav class="footer-links">
        <a href="../../index.html">Accueil</a>
        <a href="../pages_2.html">Projets</a>
        <a href="../pages_3.html">À Propos</a>
      </nav>

      <!-- Réseaux Sociaux -->
      <section class="socials">
        <a href="mailto:alexiel.landrie@gmail.com" aria-label="Envoyer un Mail">
          <i class="fas fa-envelope"></i
        ></a>
        <a
          href="https://github.com/AL-201"
          target="_blank"
          aria-label="Compte Github"
        >
          <i class="fab fa-github"></i
        ></a>
        <a
          href="https://linkedin.com"
          target="_blank"
          aria-label="Page Linkedin"
        >
          <i class="fab fa-linkedin-in"></i
        ></a>
        <a
          href="https://instagram.com"
          target="_blank"
          aria-label="Page Instagram"
        >
          <i class="fab fa-instagram"></i
        ></a>
      </section>

      <p class="credits">
        Privacy Policy · Legal · © 2025 Portfolio. All rights reserved.
      </p>
    </footer>
  </body>
</html>
